# Main

## First

不要让hr觉得你只是喜欢做前端，不喜欢来这个岗位

## Digital Twins & BIM 技术

### Known techiques

Nvidia omniverse nvdia的一个技术平台，用于方便企业接入实现 Digital twins。
甚至可以戴上 AR 或者 VR， MR 来实现观测。
而编辑器是一个基本组成。

具体可以查看 https://www.youtube.com/watch?v=Kvn0GKpydag&t=948s 
从 29 分钟开始，

## MyCareer overview

### 工作中遇到的挫折是什么？

#### 网易 game gem

网易的gamegem（时间问题，讨论时间过长，想法太天马行空，没有基于程序的水平进行程序上的技术可行性分析，），新UI编辑器给的时间太短问题（对需求要非常清晰，对基础架构的理解问题）

我刚到网易得时候，参加了一个限定24小时开发一个游戏的比赛，叫做 gamegam，主题是爷青回，我的团队都是由刚入职的学生组成，一个策划，2个程序，整个时间是从第一天晚上6点到第二天下午6点结束，中间我们花了大量的时间在讨论要做一个什么样的游戏，主要是怎么和主题结合，以及怎么做玩法创新，直到晚上凌晨4~5点，我们才开始真正动手，结果就是，在比赛结束前，我们还是未能开发完作品，这次的经历实打实的打击了我作为工程师的技术自信，我在将近一个星期的时间里面都深陷愧疚以及自卑中，毕竟我们是一个团队，我们的策划做的足够好的情况下，我们两个程序却因为经验和能力不足未能达标。

在这一周内，我主要反思了比赛过程中，我所犯的一些开发问题，

首先，虽然我们当时讨论出了一个游戏雏形，但是我们没有给这个游戏雏形做更深入的说明，甚至有些细节需求，其实都是靠每个人不同的想法去脑补，这就为后来两个程序写的功能之间产生冲突埋下隐患。


第二，没有深入的探讨技术细节，大家只是知道要大概这么做，但是我当时并没有把用到的技术以及我需要去借鉴参考的技术点罗列一下，如果前期，可以通过和伙伴进行技术讨论，或许我可以知道某个技术实现，他其实不应该按照我的某个想法来实现，因为那是走不通，浪费时间的，而是可以大家给出一个更好的方案，从而避免我走弯路。另外就是关于协作的细节，大家应该互相怎么调用功能和接口，这些在一开始通通不存在，都是当我们写了一大堆模块后，在自身bug还没修复的情况下，强行让另外一个程序来查看我得代码，看看如何整合，这是非常不好的。


第三，就是对这个项目的开发成本，没有一个最基本的量化，所有的功能模块，都要抽出来计算人力成本，在我后来规范化的开发流程中，我知道了，这些都是需要在前期尽量敲定，因为只有敲定了，我才能知道哪些功能是必要的，哪些功能是次要的，哪些是要先去做的，哪些是后来可以深入的，一个项目，他在限定的时间内，他应该开发完成到什么程度，这些都是应该去提前思考的。


最后，就是我审视自己，我在这次项目开发中，本来就处于几个不利因素，第一，我对开发工具几乎不熟悉，因为我之前只是解除游戏引擎的表现功能（UI，材质，动画，镜头调度等），现在做gameplay 逻辑开发，很多unity自带的东西，我并没有使用过，这其实并不是我得技术问题，这只是经验问题。第二，在极端高压环境下，我没有让自己处于一个井井有条的思维模式，而是处于一个混乱思维模式，这个最明显的特征就是，我在第二天的debug过程中，处于一种极端焦虑的过程导致无法进行有效debug，一大段时间都被浪费。所以我后来学会的事情，就是把我要做的东西放到一个todo list中，并且给自己尽量大的容错空间（也就是每一个task多分配点时间），在这个基础上，无论最后做成什么样子，我都能清晰的知道自己在哪块地方仍然存在问题，而不是像无头苍蝇一样不知道还差什么要去执行的，下一个要做什么。


这也是为什么我在后来的工作过程中越来越游刃有余，并且在下一个任务中，完成的比较好。


### 工作中遇到的困难是什么？怎么解决的？

比如那个鞋子不渲染的bug，首先是需要好的工具，或者收集数据，或者自己写一个工具去测试，需要自己写测试代码，活用日志工具

比如那个日常任务刷新的bug，比如全局变量的问题，怎么倒推问题，如果这个倒推出错了，要怎么办？每个步骤都打印日志出来，每一个日志都进行脑内模拟，他的数值这样是否正确，甚至可以写代码去捕捉这个值得变化

比如写一个spreadsheet

另外一个好的习惯就是把这些所思所想，都写到文档中去，避免再一次浪费思考时间

### 平时是如何和同事沟通的？

### 为什么要网易离职？



### 为什么要VCC离职？
游戏行业存在一个需求现象，就是仅仅关注视觉效果，你做的模型或者算法，只要在视觉上过得去，甚至可以形成视觉欺骗即可完成。


这个特点和你实际摸到的真实的模型是有很大差别的，他并不是用来解决实际问题的，他只能是用来作为展示使用，但是数字孪生这类则要求的，只是简单的视觉展示（可能带点数据可视化），更多的是去解决实际问题，如何调整模型，更好的预测接下来的行为，作为实际业务，更偏算法层面。

不过，无论是游戏还是数字孪生，他们都会或多或少有不少交集的算法，比如寻路，比如稀疏空间搜索等等，虽然用途不同，但是确实是method similar，甚至在开发流程上也是类似的，同样需要用准确的工程语言去描述问题，也需要定义特定的数据结构去处理数据。

另外就是随着AI的发展，我感觉如果技术栈是偏向服务器以及贴近日常业务的话，会更加贴近AI的真实使用场景，比如 智能驾驶，无人机控制等等，而这些东西，游戏行业的范围就太窄了，会让我远离日新月异的发展，我希望的是去拥抱这些新的东西。

## My Study

### 学业上遇到的最大的失败？

这个不能说是挫折吧，其实就是一个比较难的挑战，


图像处理的问题，写更多的工具去提升效率，绝不能纸上谈兵，要实地去收集数据，实地去查看为什么，怎么简单怎么来，不要轻易去尝试新技术，不一定能短时间把握


## Personal Resume

### Visual Concept China

美术工具：
1. 从另外的分支合并美术资源到我们的开发分支，同时对这些美术资源（ma文件）进行批量更新，比如增加一些额外的属性值，以及根据我们引擎的渲染管道区别去除对某些材质，某些贴图的依赖，这类文本批量处理

2. 读取 material 文件，在我们那边是 .effect，然后把他所定义的东西以及属性值都暴露到编辑器

3. 一定程度维护 shader graph，主要是将读取的 xml prototype，主要负责的就是将某个function定义成一个node，然后可视化这些node，并且连接这些node，打到生成代码的方式

任务系统
1. 先对任务进行严格定义，一个任务有6个state：locked, unlocked, started, success, finished, failed，分别对应下面的场景：
    - locked，任务未解锁，比如玩家等级没达到，或者活动还没开放
    - unlocked，任务被解锁，但是玩家还未领取任务
    - started, 玩家领取任务，任务正式开始执行
    - success，玩家完成任务
    - failed，玩家任务失败，比如该任务限定了次数，或者限定了时间范围，这个其实就是任务失效了
    - finished，玩家完成了任务

2. 其次是状态转移的条件，我们可以举一些例子看看都有哪些场景，
    - 走到某个地方任务就会执行完成
    - 通过和 npc 对话才能领取任务
    - 某个技能达到多少等级
    - 到了某个时间点，活动解锁
    
    从上面列举的，我们可以把这些都当作事件，也就是一旦任务处于某个状态，就会去监听某个事件，但是考虑到我们的项目代码比较庞大， 每个模块都不一样，你不能保证能让每个模块可以添加发事件出来的代码（比如说这个模块是不能动得代码），那么，还有另外一种，就是轮询状态，每帧去查看这个条件是否满足，但是这个东西，他也有局限性，比如说 "走到某个地方任务就会执行完成"，我岂不是要每帧去判断人物与某个位置是否有足够得物理范围碰撞，同时我还要在任务模块中添加不少其他模块得代码，比如物理相关得，你看这种情况下，还是事件比较好用。
    
    所以综合来看，应该是这两种状态转移得情况，为了综合这两种情况，我把一个状态转移得过程拆解成两部分：trigger + condition，这两个东西是和一个任务得状态进行绑定得，每个状态都有这两个。
    trigger是定义一个任务在当前状态，所监听的事件，然后一旦监听到这个事件后，就会进入下一个环节，也就是评估 condition，一旦 condition 被满足，则任务会转移到下一个状态。这样的话，trigger为空的时候，就是单纯的任务一旦进入当前状态，直接进行condition评估。如果是 condition 为空，则默认 condition 永远被满足，只要事件发生了，就会状态转移。

    还是举个例子，比如一个任务处于解锁状态，等待玩家和 NPC A 进行交互才能开始，那么 trigger就监听交互事件，condition为空，再如，一个任务处于未解锁状态，等待玩家达到50级才能解锁，那么就会有个每隔多少秒进行trigger得time trigger，然后走到condition评估玩家当前得等级是否达到要求。
    
3. Success Steps

    上面的都是不会展示到UI的情况，那么假设你的任务比较复杂，需要完成 A,B,C三件事情，而且是必须先做A，再做B，再做C，或者是 先做A，然后做B或者C都行，这样你的任务才能完成的话，就不是说仅仅一个 trigger 或者 condition 能完成的了，甚至再举个例子，这个任务是要求玩家玩三场比赛，并且每场比赛得分不低于50，那么这样的任务又该如何处理？这两个问题其实是两个维度上的问题，第一个问题，要求我得任务是可以支持任务先后顺序以及复合的，第二个问题，是要求我得任务需要有额外的存储空间，来保存我已经打过的场次。

    这就引出了 success steps 这个数据结构，他定义的是，一个任务从 success 状态走向下一个状态前，他应该先完成哪些步骤，同样，每个步骤都会有各自的trigger以及condition，另外，就是他会额外存储和自己相关的数据



## 职业规划

习惯定义问题，同时，将问题分解，擅于解决问题，不是什么东西都是通过技术去处理，行为规范也是一环

## JAVA WEB related

## Linux


## Requirement

### 程序设计规范

### 数据库

![alt text](image.png)